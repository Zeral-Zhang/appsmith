import { all, select, takeLatest, put } from "redux-saga/effects";
import { ReduxActionTypes, ReduxAction } from "constants/ReduxActionConstants";
import { actionToWidgetIdMapSuccess } from "actions/actionActions";
import { AppState } from "reducers";
import { getDynamicBindings } from "utils/DynamicBindingUtils";
import { UpdateWidgetPropertyPayload } from "actions/controlActions";
import _ from "lodash";
import { RestAction } from "api/ActionAPI";
export type ActionWidgetIdsMap = Record<string, string[]>;

function* init() {
  const data: AppState = yield select();
  const actionToWidgetIdMap: any = {};

  Object.keys(data.entities.canvasWidgets).forEach(widgetId => {
    const widget = data.entities.canvasWidgets[widgetId];
    const dynamicBindings = widget.dynamicBindings || {};

    Object.keys(dynamicBindings).forEach(key => {
      const dynamicBindingString = widget[key];
      const binding = getDynamicBindings(dynamicBindingString);
      const firstElementInPathList = binding.paths.map(
        path => path.split(".")[0],
      );
      firstElementInPathList.forEach(name => {
        const action = data.entities.actions.data.find(
          action => action.name === name,
        );
        if (action) {
          if (actionToWidgetIdMap[action.id] === undefined) {
            actionToWidgetIdMap[action.id] = [];
          }

          if (!_.includes(actionToWidgetIdMap[action.id], widgetId)) {
            actionToWidgetIdMap[action.id].push(widgetId);
          }
        }
      });
    });
  });
  yield put(actionToWidgetIdMapSuccess(actionToWidgetIdMap));
}

function getActionsForPaths(
  paths: string[],
  actions: RestAction[],
): RestAction[] {
  // Let's say dynamic binding = {{UsersTable.selectedRow}}
  return (
    paths // Get UsersTable
      .map(path => path.split(".")[0])
      // Check if the UsersTable is an action or not
      .map(apiName => {
        const action = actions.find(action => action.name === apiName);
        return action ? action : null;
      })
      // Filter the null generated by non actions
      .filter(action => action !== null) as RestAction[]
  );
}

function removeWidgetForActionId(
  actionToWidgetIdMap: ActionWidgetIdsMap,
  actionId: string,
  widgetId: string,
) {
  actionToWidgetIdMap[actionId] = actionToWidgetIdMap[actionId].filter(
    actionWidgetId => actionWidgetId !== widgetId,
  );
}

function removeWidgetFromUnboundAction(
  boundActions: RestAction[],
  actionToWidgetIdMap: ActionWidgetIdsMap,
  widgetId: string,
) {
  const mapActionIds = Object.keys(actionToWidgetIdMap);
  mapActionIds.forEach(mapActionId => {
    const actionFound = boundActions.find(boundAction => {
      return boundAction.id === mapActionId;
    });

    if (!actionFound) {
      removeWidgetForActionId(actionToWidgetIdMap, mapActionId, widgetId);
    }
  });
}

function addWidgetToBoundAction(
  boundActions: RestAction[],
  actionToWidgetIdMap: ActionWidgetIdsMap,
  widgetId: string,
) {
  boundActions.forEach(boundAction => {
    // Initiate if undefined
    if (actionToWidgetIdMap[boundAction.id] === undefined) {
      actionToWidgetIdMap[boundAction.id] = [];
    }
    // Make sure you don't push any duplicate widgetIds inside the map
    if (!_.includes(actionToWidgetIdMap[boundAction.id], widgetId)) {
      actionToWidgetIdMap[boundAction.id].push(widgetId);
    }
  });
}

function* updateAction(reduxAction: ReduxAction<UpdateWidgetPropertyPayload>) {
  const data: AppState = yield select();
  const actionsData = data.entities.actions;
  const allActions = actionsData.data;
  const actionToWidgetIdMap = {
    ...actionsData.actionToWidgetIdMap,
  };
  const { widgetId } = reduxAction.payload;

  const widget = data.entities.canvasWidgets[widgetId];
  const widgetDynamicBindings = widget.dynamicBindings as Record<
    string,
    boolean
  >;

  if (widgetDynamicBindings !== undefined) {
    const paths = Object.keys(widgetDynamicBindings)
      .map(propName => {
        const dynamicBindingString = widget[propName];
        return getDynamicBindings(dynamicBindingString);
      })
      .map(obj => obj.paths)
      .flat();

    const boundActions = getActionsForPaths(paths, allActions);
    addWidgetToBoundAction(boundActions, actionToWidgetIdMap, widgetId);
    removeWidgetFromUnboundAction(boundActions, actionToWidgetIdMap, widgetId);
  }

  yield put(
    actionToWidgetIdMapSuccess({
      ...data.entities.actions.actionToWidgetIdMap,
      ...actionToWidgetIdMap,
    }),
  );
}

export function* watchPropertyAndBindingUpdate() {
  yield takeLatest(
    [
      ReduxActionTypes.UPDATE_WIDGET_PROPERTY,
      ReduxActionTypes.UPDATE_WIDGET_DYNAMIC_PROPERTY,
    ],
    updateAction,
  );
}

export default function* watchActionWidgetMapSagas() {
  yield all([takeLatest(ReduxActionTypes.INITIALIZE_EDITOR_SUCCESS, init)]);
}
